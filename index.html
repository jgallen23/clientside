<html>
  <head>
    <title>ClientSide</title>
    <link type="text/css" rel="stylesheet" href="ui/common.css"/>
    <link type="text/css" rel="stylesheet" href="ui/ir_black.css"/>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-24017782-2']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <a href="http://github.com/jgallen23/clientside"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://a248.e.akamai.net/assets.github.com/img/7afbc8b248c68eb468279e8c17986ad46549fb71/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub"></a>
    <div id="wrapper">
<h1>ClientSide</h1>
<p>Clientside is a tool for converting a node.js library (CommonJS) into a library that is compatible in the browser.  It will parse your library, find all its dependencies, wrap all files in a closure, concatinate them and replace all require() calls with variable references.

</p>
<p>Clientside is designed for people that want to write a library and release it to the node community and the client-side javascript community.  Nodejs developers shouldn&apos;t assume that everybody is running node, so we need to provide a way for other people to use our libraries without installing something like browserify.

</p>
<p><em>Note this is still an early release, so it might not work in every case.  If you run into an issue, please add it <a href="https://github.com/jgallen23/clientside/issues">here</a>.</em>

</p>
<p>Here&apos;s a comparison ClientSide and Browserify with a couple different libraries, written CommonJS style, converted to run in the browser:

</p>
<table>
    <tr>
        <th>Tool</th>
        <th>Tiny Library (220b)</th>
        <th>Medium Library (10k)</th>
    </tr>
    <tr>
        <td>ClientSite</td>
        <td>423b</td>
        <td>10.8k</td>
    </tr>
    <tr>
        <td>Browserify</td>
        <td>9.7k</td>
        <td>22k</td>
    </tr>
</table>


<p>I think what Browserify does is fine if you are running it on your entire website where you have 100s of kb of javascript and you only add the ~9k overhead once.  But in my workflow, that doesn&apos;t work for me.  I want to write small libraries and be able to reuse them in a nodejs enviornment at home and a php enviornment at work.  

</p>
<h2>Installation</h2>
<p>Install via npm

</p>
<pre><code>npm install -g clientside</code></pre>
<h2>Usage</h2>
<pre><code>Usage: clientside [file]

Options:

    -h, --help           output usage information
    -V, --version        output the version number
    -e, --export &lt;name>  Module Name
    -v, --verify         Verifies your code <span class="keyword">in</span> a sandbox
    -s, --stats          Displays file size stats of all files

Examples:
Pass <span class="keyword">in</span> params
    $ clientside --export module index.js > dist/module.js
Read from package.json
    $ clientside > dist/module.js</code></pre>
<h2>Examples</h2>
<h3>index.js</h3>
<pre><code><span class="keyword">var</span> ClassA = require(<span class="string">'./a'</span>);

<span class="keyword">var</span> ClassB = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.a = <span class="keyword">new</span> ClassA();
    console.log(<span class="string">'ClassB init'</span>);
};

module.exports = ClassB;</code></pre>
<h3>a.js</h3>
<pre><code><span class="keyword">var</span> ClassA = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">'ClassA init'</span>);
}

module.exports = ClassA;</code></pre>
<h3>Command</h3>
<pre><code>clientside --export ClassB index.js</code></pre>
<h3>Output</h3>
<p>As you can see in the output, a.js got wrapped in a closure and set to cs1 and index.js&apos;s require(&apos;./a&apos;) call got replaced by cs1.  The entire file also got wrapped in a closure, set to the export name that was passed in, which is set to the output from the main file (index.js).

</p>
<pre><code><span class="keyword">var</span> ClassB = (<span class="function"><span class="keyword">function</span><span class="params">(exports)</span> {</span>
    <span class="keyword">var</span> cs1 = (<span class="function"><span class="keyword">function</span><span class="params">(exports)</span> {</span>
        <span class="keyword">var</span> ClassA = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            console.log(<span class="string">'ClassA init'</span>);
        }

        exports = ClassA;

        <span class="keyword">return</span> exports;
    })({});
    <span class="keyword">var</span> cs0 = (<span class="function"><span class="keyword">function</span><span class="params">(exports)</span> {</span>
        <span class="keyword">var</span> ClassA = cs1;

        <span class="keyword">var</span> ClassB = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="keyword">this</span>.a = <span class="keyword">new</span> ClassA();
            console.log(<span class="string">'ClassB init'</span>);
        };

        exports = ClassB;

        <span class="keyword">return</span> exports;
    })({});
    <span class="keyword">return</span> cs0;
})({});</code></pre>
<h2>Package.json Integration</h2>
<p>ClientSide will read your package.json if no arguments are passed in.

</p>
<pre><code>{
    <span class="string">"name"</span>: <span class="string">"SomeAwesomePackage"</span>,
    <span class="string">"main"</span>: <span class="string">"index.js"</span>,
    <span class="string">"clientside"</span>: {
        <span class="string">"shim"</span>: {
            <span class="string">"http"</span>: <span class="string">"ajax.js"</span>
        }
    }
}</code></pre>
<p>You can also add a clientside object to your package.json.  This is handy if, for example, your library makes some http requests using the http module.  In the clientside object, you can define a shim that will replace the http object with another file (in this case, replace http client with one that uses XMLHttpRequest).

</p>
<h3>a.js</h3>
<pre><code><span class="keyword">var</span> http = require(<span class="string">'http'</span>);

<span class="keyword">var</span> ClassA = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">'ClassA init'</span>);
};

module.exports = ClassA;</code></pre>
<h3>index.js</h3>
<pre><code><span class="keyword">var</span> ClassA = require(<span class="string">'./a'</span>);

<span class="keyword">var</span> ClassB = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.a = <span class="keyword">new</span> ClassA();
    console.log(<span class="string">'ClassB init'</span>);
};

module.exports = ClassB;</code></pre>
<h3>ajax.js</h3>
<pre><code>module.exports = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">"this will make ajax calls"</span>);
};</code></pre>
<h3>Output</h3>
<pre><code><span class="keyword">var</span> SomeAwesomePackage = (<span class="function"><span class="keyword">function</span><span class="params">(exports)</span> {</span>
    <span class="keyword">var</span> cs0 = (<span class="function"><span class="keyword">function</span><span class="params">(exports)</span> {</span>
        exports = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            console.log(<span class="string">"this will make ajax calls"</span>);
        };

        <span class="keyword">return</span> exports;
    })({});
    <span class="keyword">var</span> cs2 = (<span class="function"><span class="keyword">function</span><span class="params">(exports)</span> {</span>
        <span class="keyword">var</span> http = cs0;

        <span class="keyword">var</span> ClassA = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            console.log(<span class="string">'ClassA init'</span>);
        };

        exports = ClassA;

        <span class="keyword">return</span> exports;
    })({});
    <span class="keyword">var</span> cs1 = (<span class="function"><span class="keyword">function</span><span class="params">(exports)</span> {</span>
        <span class="keyword">var</span> ClassA = cs2;

        <span class="keyword">var</span> ClassB = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="keyword">this</span>.a = <span class="keyword">new</span> ClassA();
            console.log(<span class="string">'ClassB init'</span>);
        };

        exports = ClassB;

        <span class="keyword">return</span> exports;
    })({});
    <span class="keyword">return</span> cs1;
})({});</code></pre>
<h2>Future</h2>
<ul>
<li>Connect Middleware</li>
<li>Coffeescript Support</li>
</ul>
<h2>Authors</h2>
<ul>
<li>Greg Allen (<a href="http://twitter.com/jgaui">@jgaui</a>) <a href="http://jga.me">jga.me</a></li>
</ul>
</div></body></html>
